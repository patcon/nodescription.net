---
title: a drupal deployment manifesto
layout: default
published: false
tags: [drupal, devops, chef, nerd]
---

# a drupal deployment manifesto

Over at Myplanet, the company that synchronizes my circadian rhythm for awesomeness, I've been spending my days doing what some might consider R&D -- trying to figure out new workflows for deploying Drupal sites. I originally came on as a straight-up Drupal developer, but was given enough leash to start tracing my interests into this *meta*-domain of sitebuilding.

(The word "leash" sometimes carries some heavy connotations related to canine subservience (and [feline](http://commentstash.com/cat-pictures/Angry_Black_Cat_On_Leash_HX4mQc-hd94VVsDHOF1QQ.jpg) [masochism](http://25.media.tumblr.com/tumblr_lje7jgURG81qb6t6wo1_500.png)), so I'll just drop [these](http://www.angusandthetriplets.com/leashed%20babies%201.jpg) [images](http://i.walmartimages.com/i/p/00/07/15/34/53/0007153453845_AV_500X500.jpg) here to make sure we're all on the same page. They're not a bang-on accurate portrayal per se, but I'll be negotiating my monkey-backpack later this year.)

- your VCS should be your Canonical Source of Truth (CSoT). Within it, you should store no more or less than you need. No dependencies.
- Everything should be pinned. No floating git references or dev releases from drupal.org. We want to be able to regenerate a site from our CSoT at any point in the future, and have it build exactly the same artifact.
- Develop on mainline. The evil is not "features branches" per se (although I would argue that they complicate things for various reasons), but in having different branches for different destination environments. This essentially means you would have a different codebase (branch) for each environment, and this is bad. We want to simplify.
- Each commit is used to generate an artifact, which is like the "compiled" application. In drupal-speak, this artifact is most sensibly a tarball generated from the "drush archive" command.
- So that we're keeping things as simple as possible, we want to be able to deploy this single artifact (the tarball generated from a given commit) to any future environment -- local, testing, staging, production, whatever.
- Since the drupal application will need to have different configuration in each environments, this means that the app bundled up in the artifact much be environmentally-aware. Many other frameworks have the baked-in means to alter configuration based on environment, but the Drupal way of solving this would seem to involve the Environment module.
- Environment module developed by Grayside is really just as API and doesn't do anything on it's own. It can be extended through custom code to define arbitrary environments, and execute arbitrary code on transition from one to another. It allows an environment switch to be triggered either through a drush command, or by settings it globally through a $conf array entry in settings.php.
- So now that we have a way to determine environments features can allow us to have different sets of configuration based on environments, but when moving between environments, we don't want to be disabling each feature and enabling a comparable one. This would lead to lots of unnecessay bloat in features, with lots of duplication between comparable features, each destined to be enabled in a specific environment.
- Features override solves this problem for us. For each feature, we can have a base feature that we set up for our local environment, and then "stack" overrides on as we move from environment to environment, with each depending on the layer below. This has the benefit of mitigating one the largest risks to this whole approach. By that, I mean that when we have an environmentally aware site, which changes it's behavior based on it's environment, you want to know EXACTLY what's going to be changing
- We want to stack configuration.
- James: The provisioner should be used to do what it does best, bring a server into a defined start with which to host an application. Deploying and managing the app is the domain of a full-featured deployment tool like Capistrano.
- The provisioner should handle all the things in settings.php that depend on the wider infrstructure -- memcache, varnish, redis.
- Since part of this workflow assumes we're actively using Vagrant, we can assume that all the same backend software can be installed as would be available on all the "actual" environments. After all, a virtualized environment that reproduced your actual servers will always be able to run the same things, unlike when developing locally on windows. The only difference will be that the local VM environment will not be as extensive. So Varnish, memcache, and your MySQL databases will be right on the VM, as opposed to remote servers as they might be in "actual" environments. So these are the assumptions we build into the app -- that it will have all these services, but they will be local. The provisioner will generate the more elaborate configs that will generated base on the infrastructure, then included in the settings.php in a stupid way such that if-that-file-exists-include-it. So if the file doesn't exists, we run the app with all the basic settings in the artifact included for running with local services, but if the file exists, it's included and overrides as need (external memcache servers, etc.)
- is a release candidate, since any commit could in theory be promoted to production. the corrollary is that one
- Puppet vs Chef
  - Some people cite Puppet's non-ruby DSL as a reason to use it. I believe, the argument goes something like "Why add the overhead of learning another language?". How this makes sense is beyond me, as a DSL is pretty much another language, albeit simpler, so it's like asking. The reducto-el-absurdum is "Why learn the versatile Chef DSL and the Ruby language when you can just learn the limited Puppet language?" The truth is that other language communities are way ahead of us in terms of PHP in terms of TDD and deployment cultures. Many of the hot sh*t tools are being created in Ruby. And due to the way Ruby is built, it's brilliant for writing DSL's, so you can learn the DSL and not even care that you're writing in Ruby. The bonus is that whenever you feel like jumping into the think of things, and maybe writing a little Ruby logic, you've got the means to do it easily. It's like a gateway drug to another language, which you can grapple with at your own leisure. So why learn a does-one-thing DSL when you can learn as DSL written in a language that can help expose you and your team to a whole new world of tools and methologies and ideas?